

* Для чего и как создавался проект
  Небольшое демо приложение с конкретными условиями и временными окнами.
  Мои знания не ограничиваются тем, что здесь написано

* Кратко о проекте
  Инструмент, позволяющий работать с фигурами на канвасе

* Внешний вид и функциональность
  Одна сцена, 4 панели - тулбар, дерево элементов, канвас и свойсва выбранного элемента

  Операции - добавление, редактирование, удаление, ctrl+c, ctrl+v, ctrl+z

  переключение между фигурами при зажатой shift

* Архитектура
  * Общее устройство
      Гексагональная архитектура

  * Порты
    Порты - как переводчики для бизнес сделок, поэтому все UI зависимые элементы только тут, именуются с View.
    Также по этой же причине названия методов при взаимодействии с адаптерами не содержат конкретного описания
    действия, типа onClick

    Сущности данного слоя могут быть разделены на элементы и панели. Каждая панель - отдельный порт. Порты имеют
    иерархическую структуру, где RootView - корень. С остальными панелями всё ясно, а вот канвас имеет слоистую
    структуру, где каждый слой отрисовывается поверх предыдущего
      Слой подложки
      Слой с фигурами
      Слой с инструментами
    Каждый слой также имеет слоистую структуру, например у каждой также из фигур есть свойство "слой". Фигуры могут
    быть несколько на одном слое, тогда порядок их отрисовки определяется порядком добавления. Инструменты тоже
    распологаются послойно, некоторые могут сами состоять из нескольких элементов. Доступны инструменты для добавления
    фигуры на канвас, перетаскивания её и выделения с возможностью редактирования длинны и ширины.

    При необходимости передать вызов в адаптер, он передаётся напрямую в соответствующий адаптер через интерфейс.
    Цепочка зависимостей здесь идёт наружу, т.е. адаптер ничего не знает и никак не зависит от порта.

    Всё состояние внешнего вида - какая кнопка активна, какая отлючена и пр - разделёно на моды. Любое изменение внешнего
    вида происходит только через изменение активного мода, которые переключаются по state машине. Порты сами не принимают
    решение о переключении мода - оно принимается соответствующим адаптером при сигнале от порта, т.е. порт сам не обновляет
    свой внешний вид

  * Адаптеры
    Адаптеры - юридический отдел. На данным момент у приложения есть адаптеры для UI и внутреннего состояния.
    В последнем случае речь идёт о том, что место, в котором хранится состояние фигур на канвасе, считается всего
    лишь ещё одним хранилищем, таким же, как база данных на диске, облако, или монитор. Да, состояние
    фигур хранится в оперативной памяти, но общие принципы работы те же. Адаптер для работы с in-memory состоянием
    довольно простой, отмечу только, что сама Модель Данных относится к слою логики, в то время как в оперативной
    памяти хранится состояние данных. Все адаптеры пользуются одной моделью данных, но все хранимые состояния в адаптерах
    являются лишь отражением in-memory состояния и не могут быть измененны самими адаптерами - они могут только отправить логике
    сигнал о необходимости таких изменений

    Адаптеры UI также имеют иерархическую структуру, во многом повторяющую структуру портов. Имеет своё состояние, которое
    включает текущий выбранный элемент, скопированный элемент, текущий мод, описаный ранее и пр - грубо говоря, любой слой
    может иметь свою модель и своё состояние при необходимости. Однако изменять он может только состояние сущностей
    своей модели, но не из модели более глубоких слоёв. Так ui адаптер может изменять текущую выбранную фигуру, но если
    от порта пришёл сигнал о изменении самой фигуры, задача адаптера только в пробросе сигнала в более глубокий слой

  * Обработчик логики(контроллер?) & validation
    Сигналы о изменении фигур обрабатываются своим обработчиком. Перед выполнением операции проверяется валидность
    всех параметров. После чего генерируется соответвующая команда и передаётся обрабочику команд

  * Команды
    Каждое изменение состояния данных приложения осуществляется только через команды, которые журналируются для
    возможности отмены ранее совершённых действий. Для этого команда хранит как оригинальные, так и изменённые данные.
    Каждая из команд может обращаться к соответвующим сервисам логики(которые в данной сборке отсутствуют), так и к
    контроллерам для чтения/записи данных

  * Модель данный и Состояние приложения
    Реализован шаблон State, позволяющий быстро переключаться между состояними - подменили стейт и обновили все адаптеры.
    Также в модель включены всякие DTO и прочие дополнительные сущности

  * DI & interfaces
    Приложение собранно на интерфейсах, инициализируется через DI либо при запуске

  * Конфигурация при запуске
    Демо версия конфигов при запуске

  * логгирование
    Дебаг в консоль, ошибки в консоль и файл. Также используются метки для более лёгкой фильтрации вывода

  * асинхронность
    UI живёт в своём потоке, чтобы не фризить который все операции по изменению фигур выполняются в других потоках.
    После результат выполнения возвращается в UI с помощью Platform::runLater. Таким образом, граница асинхронности
    сейчас проходит между адаптером и логикой. Использование интерфейсов позволяет, с помощью обёрток, отделить
    логику изменения потока от бизнес логики. Таким образом, один объект думает, что обращается к другому, не зная,
    что на самом деле обращение идёт к обёртке, что позволяет держать логику работы чистой от деталей реализации.
    А благодаря DI это происходит только подменой объекта конструктора в DI контейнере, т.е. не требует никаких изменений
    в существующем коде

  * транспортный уровень
    Общение между адаптером и логикой идёт через шину сообщений. Здесь она просто замокана для демонстрации. С помощью
    уже знакомых обёрток вызов перехватывается, генерируется ивент, который затем передаётся в канал. Из канала ивент
    получает подписанный обработчик, который разворачивает ивент в набор параметров, которые затем передаются в нужный
    элемент логики. Также, как и с асинхронностью, это необходимо для отделения логики маршрутизации ивентов от бизнес
    логики самого приложения. Грубо говоря, два элемента думают, что общаются между собой, хотя между ними может быть
    сразу несколько обёрток для тех или иных функций

* Сборка

* Тесты
   Были написанны несколько тестов каждой категории, т.к. лишь это демо
     юнит тесты
     интеграционные тесты
     UI тесты с помощью TestFX

* Дополнительно
   При инициализации используются кастомные фабрики контроллеров и нодов, для возможности использовать DI.


* API